### 1. 冒泡排序

* 实现思路：是最基本的排序算法，通过将前一个和后一个数据逐一比较，若前一个大/小，则交换位置，在第一轮交换之后，最后一个数为最大/小的数，所以每次的小循环都少一次运算。同时设置一个flag标志，若一轮循环之后没有进行过一次交换，则表明已经排序完成，则直接跳出运算，返回结果。
* 代码实现如下：

~~~java
import java.util.Arrays;

public class BubbleSort {
    
    public static void bubbleSort(int[] nums) {
        boolean flag = true;//标志位为假则表示交换过，否则跳出排序
        for(int i = 0; i < nums.length; i ++) {
            for(int j = 1; j < nums.length - i; j++) {
                if(nums[j - 1] > nums[j]) {
                    swap(nums, j - 1, j);
                    flag = false;
                }
            }
            //若未交换则直接返回
            if(!flag) break;
            flag = true;
        }
    }
    
    //进行交换的辅助函数
    public static void swap(int[] nums, int x, int y) {
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }
}
~~~

### 2. 插入排序

* 实现原理：在一个已经排序好的数组中插入一个数据，则需要对该数据的位置进行查找，若找到了则直接将改数据插入即可。插入排序就是将需要排序的数组分为两部分，已排序好的和等待排序的，一次从等待排序中取出一个数据放入按序放入已排序好的部分中，直到数据取出完毕。
* 实现代码：

~~~java
import java.util.Arrays;

public class InsertionSort {
    public static void insertionSort(int[] nums) {
        for(int i = 1; i < nums.length; i ++) {
            //拿出要插入的数据
            int num = nums[i];
            //进行插入寻找并连续的交换位置
            for(int j = i - 1; j >= 0 && nums[j] < nums[i]; j--) {
                nums[j + 1] = nums[j];
            }
            nums[j + 1] = num;
        }
    }
}
~~~

